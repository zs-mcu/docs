---
autoSort: 9999
---

# base基本功能

## 历史命令

> 参考： [23、history.md](../基本使用/23、history.md) 

## 命令与文件的补全

> 略

## 命令别名

> 参考： [24、alias.md](../基本使用/24、alias.md) 

## Bash常用快捷键

| 快捷键 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| Tab键  | 命令或文件补全                                               |
| ctrl+a | 把光标移动到命令行开头。<br />如果我们输入的命令过长，想要把光标移动到命令行开头时使用。 |
| ctrl+e | 把光标移动到命令行结尾。                                     |
| ctrl+c | 强制终止当前的命令。                                         |
| ctrl+l | 清屏，相当于clear命令。                                      |
| ctrl+u | 删除或剪切光标之前的命令。<br />我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便 |
| ctrl+y | 粘贴`ctrl+u`剪切的内容。                                     |
| ctrl+k | 粘贴`ctrl+u`或`ctrl+k`剪切的内容。                           |
| ctrl+r | 在历史命令中搜索，按下`ctrl+r`之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索。 |
| ctrl+d | 退出当前终端。                                               |
| ctrl+z | 暂停，并放入后台。这个快捷键牵扯工作管理的内容，我们在系统管理章节详细介绍。 |
| ctrl+s | 暂停屏幕输出。                                               |
| ctrl+q | 恢复屏幕输出。                                               |

## 输入输出重定向

1）、bash的标准输入输出

| 设备   | 设备文件名    | 文件描述符 | 类型         |
| ------ | ------------- | ---------- | ------------ |
| 键盘   | `/dev/stdin`  | 0          | 标准输入     |
| 显示器 | `/dev/stdout` | 1          | 标准输出     |
| 显示器 | `/dev/stderr` | 2          | 标准错误输出 |

2）、输出重定向

| 类型                       | 符号                  | 作用                                                       |
| -------------------------- | --------------------- | ---------------------------------------------------------- |
| 标准输出重定向             | 命令 > 文件           | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中。 |
|                            | 命令 >> 文件          | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中。 |
| 标准错误输出重定向         | 错误命令 2> 文件      | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。 |
|                            | 错误命令 2>> 文件     | 以追加的方式，把命令的错误输出输出到指定的文件或设备当中。 |
| 正确输出和错误输出同时保存 | 命令 > 文件 2>&1      | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。 |
|                            | 命令>>文件2>&1        | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中。 |
|                            | 命令&>文件            | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中。 |
|                            | 命令&>>文件           | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中。 |
|                            | 命令>>文件1  2>>文件2 | 把正确的输出追加到文件1中，把错误的输出追加到文件2中。     |

3）、输入重定向

```powershell
[root@localhost ~]# wc [选项] [文件名]
选项：
    -c	统计字节数
    -w	统计单词数
    -l	统计行数
    
    
[jysp@xiaoshaozi root]$ wc << uio
> 1234
> 1234
> 1234
> 12345
> uio
 4  4 21


```

## 多命令顺序执行

| 多命令执行符 | 格式            | 作用                                                         |
| ------------ | --------------- | ------------------------------------------------------------ |
| `;`          | `命令1;命令2`   | 多个命令顺序执行，命令之间没有任何逻辑联系                   |
| `&&`         | `命令1 &&命令2` | 当命令1正确执行  `（$?=0）`，则命令2才会执行<br />当命令1执行不正确`（$?≠0）`，则命令2不会执行命令1 |
| `||`         | `命令1||命令2`  | 当命令1执行不正确`（$?≠0）`，则命令2才会执行<br />当命令1正确执行（$?=0），则命令2不会执行 |



```powershell
同时执行
[root@xiaoshaozi ~]# ls;date;cd /etc
hello.sh
2023年 12月 20日 星期三 16:38:14 CST
[root@xiaoshaozi etc]# 

正确执行 命令1，才执行，命令2
[root@xiaoshaozi ~]# ls && echo yes
hello.sh
yes

正确执行 输出yes,错误执行 输出no
[root@xiaoshaozi ~]# ls && echo yes || echo no
hello.sh
yes
[root@xiaoshaozi ~]# ls123 && echo yes || echo no
bash: ls123: 未找到命令
no
```



## 管道符

> 参考： [19、管道.md](../基本使用/19、管道.md) 

## 通配符

| 通配符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| `?`    | 匹配一个任意字符                                             |
| `*`    | 匹配0个或任意多个任意字符，<br />也就是可以匹配任何内容      |
| `[]`   | 匹配中括号中任意一个字符。<br />例如：`[abc]`代表一定匹配一个字符，或者是a，或者是b，或者是c。 |
| `[-]`  | 匹配中括号中任意一个字符，代表一个范围。<br />例如：`[a-z]`代表匹配一个小写字母。 |
| `[^]`  | 逻辑非，表示匹配不是中括号内的一个字符。<br />例如：`[^0-9]`代表匹配一个不是数字的字符。 |
|        |                                                              |



## Bash中其他特殊符号

| 符号         | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| `''`         | 单引号。<br />在单引号中所有的特殊符号，如`"$"`和```` "`" ````(反引号)都没有特殊含义。 |
| `""`         | 双引号。<br />在双引号中特殊符号都没有特殊含义，<br />但是`“$”`、```` “`” ````和`“\”`是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。 |
| ```` `` ```` | 反引号。<br />反引号括起来的内容是系统命令，在Bash中会先执行它。<br />和$()作用一样，不过推荐使用$()，因为反引号非常容易看错。 |
| `$()`        | 和反引号作用一样，用来引用系统命令。                         |
| `()`         | 用于一串命令执行时，()中的命令会在子Shell中运行              |
| `{}`         | 用于一串命令执行时，{}中的命令会在当前Shell中执行。也可以用于变量变形与替换。 |
| `[]`         | 用于变量的测试。                                             |
| `#`          | 在Shell脚本中，#开头的行代表注释。                           |
| `$`          | 用于调用变量的值，如需要调用变量name的值时，需要用`$name`的方式得到变量的值。 |
| `\`          | 转义符，跟在`\`之后的特殊符号将失去特殊含义，变为普通字符。如`\$`将输出`“$”`符号，而不当做是变量引用。 |
|              |                                                              |

1）、单引号和双引号

```powershell
定义变量name的值是sc（就是最正直的人，超哥我了！）
[root@xiaoshaozi ~]# name=sc

如果输出时使用单引号，则$name原封不动的输出
[root@xiaoshaozi ~]# echo '$name'
$name

如果输出时使用双引号，则会输出变量name的值sc
[root@xiaoshaozi ~]# echo "$name"
sc


[root@xiaoshaozi ~]# echo $name
sc
```

2）、反引号

> 可以看懂
> 不推荐使用，推荐使用`$()`作用是一样的

```powershell
执行命令，输出
[root@xiaoshaozi ~]# echo `date`
2023年 12月 20日 星期三 17:08:29 CST

输出 字符串
[root@xiaoshaozi ~]# echo '`date`'
`date`

执行命令，输出
[root@xiaoshaozi ~]# echo "`date`"
2023年 12月 20日 星期三 17:09:05 CST


[root@xiaoshaozi ~]# echo "date"
date


```

3）、小括号、中括号和大括号

在介绍小括号和大括号的区别之前，我们先要解释一个概念，那就是父Shell和子Shell。

在我们的bash中，是可以调用新的bash的，比如：

```powershell
[root@xiaoshaozi ~]# bash
[root@xiaoshaozi ~]# pstree
systemd─┬─AliYunDun───10*[{AliYunDun}]
…省略部分输出
        ├─sshd───sshd─┬─bash───sleep
        │             ├─bash───su───bash───bash───pstree
        │             └─bash───top
 …省略部分输出
[root@xiaoshaozi ~]# 
```

知道了父Shell和子Shell，我们接着解释小括号和大括号的区别。如果是用于一串命令的执行，那么小括号和大括号的主要区别在于：

`()`执行一串命令时，需要重新开一个子shell进行执行
`{}`执行一串命令时，是在当前shell执行；
`()`和`{}`都是把一串的命令放在括号里面，并且命令之间用;号隔开；
`()`最后一个命令可以不用分号；
`{}`最后一个命令要用分号；
`{}`的第一个命令和左括号之间必须要有一个空格；
`()`里的各命令不必和括号有空格；
`()`和`{}`中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令。

还是举几个例子来看看吧，这样写实在是太抽象了：



```powershell
[root@xiaoshaozi ~]# name=sc

# 在父Shell中定义变量name的值是sc
# 如果用()括起来一串命令，这些命令都可以执行
# 给name变量重新赋值，但是这个值只在子Shell中生效
[root@xiaoshaozi ~]# (name=xiaoshaozi;echo $name)
xiaoshaozi
[root@xiaoshaozi ~]# echo $name
sc

# 但是用大括号来进行一串命令的执行时，name变量的修改是直接在父Shell当中的
# 注意大括号的格式
[root@xiaoshaozi ~]# { name=xiaoshaozi;echo $name; }
xiaoshaozi
[root@xiaoshaozi ~]# echo $name
xiaoshaozi
[root@xiaoshaozi ~]# 

```











